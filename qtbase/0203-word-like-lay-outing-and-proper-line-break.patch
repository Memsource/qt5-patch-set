From d02967d1804ca7957a98cdf235965f96a423eaee Mon Sep 17 00:00:00 2001
From: "michal.lazo" <michal.lazo@memsource.com>
Date: Fri, 21 Sep 2018 08:50:29 +0200
Subject: [PATCH] word like lay-outing and proper line-break

---
 src/gui/text/qtextengine.cpp |  22 +++-----
 src/gui/text/qtextengine_p.h |   5 +-
 src/gui/text/qtextlayout.cpp | 102 ++++++++++++++++++++++++++++-------
 src/gui/text/qtextoption.h   |   1 +
 4 files changed, 94 insertions(+), 36 deletions(-)

diff --git a/src/gui/text/qtextengine.cpp b/src/gui/text/qtextengine.cpp
index 87dc63d59c..9e90833f2b 100644
--- a/src/gui/text/qtextengine.cpp
+++ b/src/gui/text/qtextengine.cpp
@@ -2057,29 +2057,21 @@ void QTextEngine::itemize() const
             analysis->flags = QScriptAnalysis::Object;
             break;
         case QChar::LineSeparator:
-            if (analysis->bidiLevel % 2)
-                --analysis->bidiLevel;
             analysis->flags = QScriptAnalysis::LineOrParagraphSeparator;
-            if (option.flags() & QTextOption::ShowLineAndParagraphSeparators) {
-                const int offset = uc - string;
-                layoutData->string.detach();
-                string = reinterpret_cast<const ushort *>(layoutData->string.unicode());
-                uc = string + offset;
-                e = string + length;
-                *const_cast<ushort*>(uc) = 0x21B5; // visual line separator
-            }
             break;
         case QChar::Tabulation:
             analysis->flags = QScriptAnalysis::Tab;
             analysis->bidiLevel = bidi.baseLevel;
             break;
         case QChar::Space:
+        case 0x3000: // IdeologicalSpace
+            analysis->flags = QScriptAnalysis::Space;
+            analysis->bidiLevel = bidi.baseLevel;
+            break;
         case QChar::Nbsp:
-            if (option.flags() & QTextOption::ShowTabsAndSpaces) {
-                analysis->flags = QScriptAnalysis::Space;
-                break;
-            }
-            Q_FALLTHROUGH();
+            analysis->flags = QScriptAnalysis::NonBreakingSpace;
+            analysis->bidiLevel = bidi.baseLevel;
+            break;
         default:
             analysis->flags = QScriptAnalysis::None;
             break;
diff --git a/src/gui/text/qtextengine_p.h b/src/gui/text/qtextengine_p.h
index f9eb055478..d7a09bbe93 100644
--- a/src/gui/text/qtextengine_p.h
+++ b/src/gui/text/qtextengine_p.h
@@ -142,9 +142,10 @@ struct Q_AUTOTEST_EXPORT QScriptAnalysis
         LineOrParagraphSeparator = 4,
         Space = 5,
         SpaceTabOrObject = Space,
-        Tab = 6,
+        NonBreakingSpace = 6,
+        Tab = 7,
         TabOrObject = Tab,
-        Object = 7
+        Object = 8
     };
     enum BidiFlags {
         BidiBN = 1,
diff --git a/src/gui/text/qtextlayout.cpp b/src/gui/text/qtextlayout.cpp
index 6e824b2ed1..b4032dc019 100644
--- a/src/gui/text/qtextlayout.cpp
+++ b/src/gui/text/qtextlayout.cpp
@@ -1711,7 +1711,7 @@ namespace {
 
         inline void calculateRightBearing()
         {
-            if (currentPosition <= 0)
+            if (currentPosition <= 0 || glyphs.numGlyphs == 0 || logClusters[currentPosition-1] >= glyphs.numGlyphs)
                 return;
             calculateRightBearing(fontEngine, currentGlyph());
         }
@@ -1827,6 +1827,8 @@ void QTextLine::layout_helper(int maxGlyphs)
     lbh.logClusters = eng->layoutData->logClustersPtr;
     lbh.previousGlyph = 0;
 
+    bool useWordLikeLayout = eng->option.flags() & QTextOption::WordLikeLayout;
+    bool previousSpace = false;
     while (newItem < eng->layoutData->items.size()) {
         lbh.resetRightBearing();
         lbh.softHyphenWidth = 0;
@@ -1896,9 +1898,18 @@ void QTextLine::layout_helper(int maxGlyphs)
                 lbh.tmpData.length++;
                 lbh.calculateRightBearingForPreviousGlyph();
             }
-            line += lbh.tmpData;
+            if (useWordLikeLayout) {
+                lbh.checkFullOtherwiseExtend(line);
+            } else {
+                line += lbh.tmpData;
+            }
             goto found;
         } else if (current.analysis.flags == QScriptAnalysis::Object) {
+            if (useWordLikeLayout &&
+                ((breakany && lbh.checkFullOtherwiseExtend(line)) ||
+                (previousSpace == true && lbh.checkFullOtherwiseExtend(line)))) {
+                goto found;
+            }
             lbh.whiteSpaceOrObject = true;
             lbh.tmpData.length++;
 
@@ -1911,27 +1922,43 @@ void QTextLine::layout_helper(int maxGlyphs)
 
             newItem = item + 1;
             ++lbh.glyphCount;
-            if (lbh.checkFullOtherwiseExtend(line))
+            if (!useWordLikeLayout && lbh.checkFullOtherwiseExtend(line))
                 goto found;
-        } else if (attributes[lbh.currentPosition].whiteSpace
+        } else if (!useWordLikeLayout &&
+                   attributes[lbh.currentPosition].whiteSpace
                    && eng->layoutData->string.at(lbh.currentPosition).decompositionTag() != QChar::NoBreak) {
             lbh.whiteSpaceOrObject = true;
+            lbh.saveCurrentGlyph();
             while (lbh.currentPosition < end
                    && attributes[lbh.currentPosition].whiteSpace
-                   && eng->layoutData->string.at(lbh.currentPosition).decompositionTag() != QChar::NoBreak) {
+                   && eng->layoutData->string.at( lbh.currentPosition ).decompositionTag() != QChar::NoBreak ) {
                 addNextCluster(lbh.currentPosition, end, lbh.spaceData, lbh.glyphCount,
                                current, lbh.logClusters, lbh.glyphs);
             }
 
-            if (!lbh.manualWrap && lbh.spaceData.textWidth > line.width) {
-                lbh.spaceData.textWidth = line.width; // ignore spaces that fall out of the line.
+            if (!lbh.manualWrap && lbh.checkFullOtherwiseExtend(line )) {
+                lbh.spaceData.textWidth = 0;
+                lbh.spaceData.length = 0;
                 goto found;
             }
+            lbh.saveCurrentGlyph();
         } else {
             lbh.whiteSpaceOrObject = false;
             bool sb_or_ws = false;
+            bool canBreak = false; 
             lbh.saveCurrentGlyph();
             do {
+                if (useWordLikeLayout) {
+                    const bool noBreak = eng->layoutData->string.at( lbh.currentPosition ).decompositionTag() == QChar::NoBreak;
+
+                    if (!noBreak && attributes[lbh.currentPosition].whiteSpace) {
+                        previousSpace = true;
+                    } else if (previousSpace) {
+                        canBreak = true;
+                        break;
+                    }
+                }
+
                 addNextCluster(lbh.currentPosition, end, lbh.tmpData, lbh.glyphCount,
                                current, lbh.logClusters, lbh.glyphs);
 
@@ -1944,11 +1971,17 @@ void QTextLine::layout_helper(int maxGlyphs)
                                         && attributes[lbh.currentPosition].whiteSpace
                                         && eng->layoutData->string.at(lbh.currentPosition).decompositionTag() != QChar::NoBreak;
 
-                if (lbh.currentPosition >= eng->layoutData->string.length()
+                if (!useWordLikeLayout &&
+                   (lbh.currentPosition >= eng->layoutData->string.length()
                     || isBreakableSpace
-                    || attributes[lbh.currentPosition].lineBreak) {
+                    || attributes[lbh.currentPosition].lineBreak)) {
                     sb_or_ws = true;
                     break;
+                } else if (useWordLikeLayout &&
+                           (lbh.currentPosition >= eng->layoutData->string.length()
+                           || (attributes[lbh.currentPosition].lineBreak && isBreakableSpace))) {
+                    canBreak = true;
+                    break;
                 } else if (breakany && attributes[lbh.currentPosition].graphemeBoundary) {
                     break;
                 }
@@ -1980,7 +2013,8 @@ void QTextLine::layout_helper(int maxGlyphs)
                     lbh.tmpData.textWidth += lbh.glyphs.advances[lbh.logClusters[lbh.currentPosition - 1]];
             }
 
-            if (sb_or_ws|breakany) {
+            if (canBreak|sb_or_ws|breakany) {
+                previousSpace = false;
                 // To compute the final width of the text we need to take negative right bearing
                 // into account (negative right bearing means the glyph has pixel data past the
                 // advance length). Note that the negative right bearing is an absolute number,
@@ -2445,8 +2479,9 @@ void QTextLine::draw(QPainter *p, const QPointF &pos, const QTextLayout::FormatR
     QPen pen = p->pen();
 
     bool noText = (selection && selection->format.property(SuppressText).toBool());
+    bool rtl = (eng->block.document() && eng->block.document()->defaultTextOption().textDirection() == Qt::RightToLeft);
 
-    if (!line.length) {
+    if (!line.length && !(eng->option.flags() & QTextOption::ShowLineAndParagraphSeparators)) {
         if (selection
             && selection->start <= line.from
             && selection->start + selection->length > line.from) {
@@ -2483,6 +2518,11 @@ void QTextLine::draw(QPainter *p, const QPointF &pos, const QTextLayout::FormatR
         QFont f = eng->font(si);
         QTextCharFormat format;
 
+        QFixed itemY = y - si.ascent;
+        if (format.verticalAlignment() == QTextCharFormat::AlignTop) {
+            itemY = y - lineBase;
+        }
+
         if (eng->hasFormats() || selection) {
             format = eng->format(&si);
             if (suppressColors) {
@@ -2512,10 +2552,6 @@ void QTextLine::draw(QPainter *p, const QPointF &pos, const QTextLayout::FormatR
             if (eng->hasFormats()) {
                 p->save();
                 if (si.analysis.flags == QScriptAnalysis::Object && eng->block.docHandle()) {
-                    QFixed itemY = y - si.ascent;
-                    if (format.verticalAlignment() == QTextCharFormat::AlignTop) {
-                        itemY = y - lineBase;
-                    }
 
                     QRectF itemRect(iterator.x.toReal(), itemY.toReal(), iterator.itemWidth.toReal(), si.height().toReal());
 
@@ -2611,16 +2647,44 @@ void QTextLine::draw(QPainter *p, const QPointF &pos, const QTextLayout::FormatR
         } else {
             if (noText)
                 gf.glyphs.numGlyphs = 0; // slightly less elegant than it should be
-            QPainterPrivate::get(p)->drawTextItem(pos, gf, eng);
+            if ((eng->option.flags() & QTextOption::ShowLineAndParagraphSeparators) &&
+                si.analysis.flags == QScriptAnalysis::LineOrParagraphSeparator) {
+                QChar visualLine;
+                if ((index == eng->lines.size() - 1) && (eng->block.next().isValid() != false)) {
+                    visualLine = (ushort)0xB6;
+                } else if (iterator.itemStart < (eng->layoutData->string.length() - 1)) {
+                    if (rtl) {
+                        visualLine = ((ushort)0x21aa);
+                        pos = QPointF((line.width - line.textWidth).toReal(), y.toReal());
+                    } else {
+                        visualLine = ((ushort)0x21a9);
+                    }
+                }
+                if (visualLine.unicode()) {
+                    QBrush c = format.foreground();
+                    if(c.style() != Qt::NoBrush)
+                        p->setPen(c.color());
+                    p->drawText(pos, visualLine);
+                    p->setPen(pen);
+                }
+            } else {
+                QPainterPrivate::get(p)->drawTextItem(pos, gf, eng);
+            }
         }
 
-        if (si.analysis.flags == QScriptAnalysis::Space
+        // TODO: fix NonBreakingSpace draw size
+        if ((si.analysis.flags == QScriptAnalysis::Space || si.analysis.flags == QScriptAnalysis::NonBreakingSpace)
             && (eng->option.flags() & QTextOption::ShowTabsAndSpaces)) {
             QBrush c = format.foreground();
             if (c.style() != Qt::NoBrush)
                 p->setPen(c.color());
-            QChar visualSpace((ushort)0xb7);
-            p->drawText(QPointF(iterator.x.toReal(), itemBaseLine.toReal()), visualSpace);
+            QChar visualSpace;
+            if (si.analysis.flags == QScriptAnalysis::Space) {
+                visualSpace = QChar((ushort)0xb7);
+            } else {
+                visualSpace = QChar((ushort)0xb0);
+            }
+            p->drawText(pos, visualSpace);
             p->setPen(pen);
         }
     }
diff --git a/src/gui/text/qtextoption.h b/src/gui/text/qtextoption.h
index 8b57278633..9662122f4c 100644
--- a/src/gui/text/qtextoption.h
+++ b/src/gui/text/qtextoption.h
@@ -111,6 +111,7 @@ public:
         AddSpaceForLineAndParagraphSeparators = 0x4,
         SuppressColors = 0x8,
         ShowDocumentTerminator = 0x10,
+        WordLikeLayout = 0x20,
         IncludeTrailingSpaces = 0x80000000
     };
     Q_DECLARE_FLAGS(Flags, Flag)
-- 
2.18.0.windows.1

